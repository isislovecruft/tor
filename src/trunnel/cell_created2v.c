/* cell_created2v.c -- generated by Trunnel v1.5.2.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#include <stdlib.h>
#include "trunnel-impl.h"

#include "cell_created2v.h"

#define TRUNNEL_SET_ERROR_CODE(obj) \
  do {                              \
    (obj)->trunnel_error_code_ = 1; \
  } while (0)

#if defined(__COVERITY__) || defined(__clang_analyzer__)
/* If we're running a static analysis tool, we don't want it to complain
 * that some of our remaining-bytes checks are dead-code. */
int cellcreatedv_deadcode_dummy__ = 0;
#define OR_DEADCODE_DUMMY || cellcreatedv_deadcode_dummy__
#else
#define OR_DEADCODE_DUMMY
#endif

#define CHECK_REMAINING(nbytes, label)                           \
  do {                                                           \
    if (remaining < (nbytes) OR_DEADCODE_DUMMY) {                \
      goto label;                                                \
    }                                                            \
  } while (0)

create2v_cell_body_t *
create2v_cell_body_new(void)
{
  create2v_cell_body_t *val = trunnel_calloc(1, sizeof(create2v_cell_body_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
create2v_cell_body_clear(create2v_cell_body_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->hdata);
  TRUNNEL_DYNARRAY_CLEAR(&obj->hdata);
  TRUNNEL_DYNARRAY_WIPE(&obj->ignored);
  TRUNNEL_DYNARRAY_CLEAR(&obj->ignored);
}

void
create2v_cell_body_free(create2v_cell_body_t *obj)
{
  if (obj == NULL)
    return;
  create2v_cell_body_clear(obj);
  trunnel_memwipe(obj, sizeof(create2v_cell_body_t));
  trunnel_free_(obj);
}

uint16_t
create2v_cell_body_get_htype(const create2v_cell_body_t *inp)
{
  return inp->htype;
}
int
create2v_cell_body_set_htype(create2v_cell_body_t *inp, uint16_t val)
{
  inp->htype = val;
  return 0;
}
uint16_t
create2v_cell_body_get_hlen(const create2v_cell_body_t *inp)
{
  return inp->hlen;
}
int
create2v_cell_body_set_hlen(create2v_cell_body_t *inp, uint16_t val)
{
  inp->hlen = val;
  return 0;
}
size_t
create2v_cell_body_getlen_hdata(const create2v_cell_body_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->hdata);
}

uint8_t
create2v_cell_body_get_hdata(create2v_cell_body_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->hdata, idx);
}

uint8_t
create2v_cell_body_getconst_hdata(const create2v_cell_body_t *inp, size_t idx)
{
  return create2v_cell_body_get_hdata((create2v_cell_body_t*)inp, idx);
}
int
create2v_cell_body_set_hdata(create2v_cell_body_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->hdata, idx, elt);
  return 0;
}
int
create2v_cell_body_add_hdata(create2v_cell_body_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT16_MAX
  if (inp->hdata.n_ == UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->hdata, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
create2v_cell_body_getarray_hdata(create2v_cell_body_t *inp)
{
  return inp->hdata.elts_;
}
const uint8_t  *
create2v_cell_body_getconstarray_hdata(const create2v_cell_body_t *inp)
{
  return (const uint8_t  *)create2v_cell_body_getarray_hdata((create2v_cell_body_t*)inp);
}
int
create2v_cell_body_setlen_hdata(create2v_cell_body_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT16_MAX < SIZE_MAX
  if (newlen > UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->hdata.allocated_,
                 &inp->hdata.n_, inp->hdata.elts_, newlen,
                 sizeof(inp->hdata.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->hdata.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
create2v_cell_body_getlen_ignored(const create2v_cell_body_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->ignored);
}

uint8_t
create2v_cell_body_get_ignored(create2v_cell_body_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->ignored, idx);
}

uint8_t
create2v_cell_body_getconst_ignored(const create2v_cell_body_t *inp, size_t idx)
{
  return create2v_cell_body_get_ignored((create2v_cell_body_t*)inp, idx);
}
int
create2v_cell_body_set_ignored(create2v_cell_body_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->ignored, idx, elt);
  return 0;
}
int
create2v_cell_body_add_ignored(create2v_cell_body_t *inp, uint8_t elt)
{
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->ignored, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
create2v_cell_body_getarray_ignored(create2v_cell_body_t *inp)
{
  return inp->ignored.elts_;
}
const uint8_t  *
create2v_cell_body_getconstarray_ignored(const create2v_cell_body_t *inp)
{
  return (const uint8_t  *)create2v_cell_body_getarray_ignored((create2v_cell_body_t*)inp);
}
int
create2v_cell_body_setlen_ignored(create2v_cell_body_t *inp, size_t newlen)
{
  uint8_t *newptr;
  newptr = trunnel_dynarray_setlen(&inp->ignored.allocated_,
                 &inp->ignored.n_, inp->ignored.elts_, newlen,
                 sizeof(inp->ignored.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->ignored.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
create2v_cell_body_check(const create2v_cell_body_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->hdata) != obj->hlen)
    return "Length mismatch for hdata";
  return NULL;
}

ssize_t
create2v_cell_body_encoded_len(const create2v_cell_body_t *obj)
{
  ssize_t result = 0;

  if (NULL != create2v_cell_body_check(obj))
     return -1;


  /* Length of u16 htype */
  result += 2;

  /* Length of u16 hlen */
  result += 2;

  /* Length of u8 hdata[hlen] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->hdata);

  /* Length of u8 ignored[] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->ignored);
  return result;
}
int
create2v_cell_body_clear_errors(create2v_cell_body_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
create2v_cell_body_encode(uint8_t *output, const size_t avail, const create2v_cell_body_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = create2v_cell_body_encoded_len(obj);
#endif

  if (NULL != (msg = create2v_cell_body_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u16 htype */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->htype));
  written += 2; ptr += 2;

  /* Encode u16 hlen */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->hlen));
  written += 2; ptr += 2;

  /* Encode u8 hdata[hlen] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->hdata);
    trunnel_assert(obj->hlen == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->hdata.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }

  /* Encode u8 ignored[] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->ignored);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->ignored.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As create2v_cell_body_parse(), but do not allocate the output
 * object.
 */
static ssize_t
create2v_cell_body_parse_into(create2v_cell_body_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u16 htype */
  CHECK_REMAINING(2, truncated);
  obj->htype = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u16 hlen */
  CHECK_REMAINING(2, truncated);
  obj->hlen = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u8 hdata[hlen] */
  CHECK_REMAINING(obj->hlen, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->hdata, obj->hlen, {});
  obj->hdata.n_ = obj->hlen;
  if (obj->hlen)
    memcpy(obj->hdata.elts_, ptr, obj->hlen);
  ptr += obj->hlen; remaining -= obj->hlen;

  /* Parse u8 ignored[] */
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->ignored, remaining, {});
  obj->ignored.n_ = remaining;
  if (remaining)
    memcpy(obj->ignored.elts_, ptr, remaining);
  ptr += remaining; remaining -= remaining;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
create2v_cell_body_parse(create2v_cell_body_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = create2v_cell_body_new();
  if (NULL == *output)
    return -1;
  result = create2v_cell_body_parse_into(*output, input, len_in);
  if (result < 0) {
    create2v_cell_body_free(*output);
    *output = NULL;
  }
  return result;
}
created2v_cell_body_t *
created2v_cell_body_new(void)
{
  created2v_cell_body_t *val = trunnel_calloc(1, sizeof(created2v_cell_body_t));
  if (NULL == val)
    return NULL;
  return val;
}

/** Release all storage held inside 'obj', but do not free 'obj'.
 */
static void
created2v_cell_body_clear(created2v_cell_body_t *obj)
{
  (void) obj;
  TRUNNEL_DYNARRAY_WIPE(&obj->hdata);
  TRUNNEL_DYNARRAY_CLEAR(&obj->hdata);
  TRUNNEL_DYNARRAY_WIPE(&obj->ignored);
  TRUNNEL_DYNARRAY_CLEAR(&obj->ignored);
}

void
created2v_cell_body_free(created2v_cell_body_t *obj)
{
  if (obj == NULL)
    return;
  created2v_cell_body_clear(obj);
  trunnel_memwipe(obj, sizeof(created2v_cell_body_t));
  trunnel_free_(obj);
}

uint16_t
created2v_cell_body_get_hlen(const created2v_cell_body_t *inp)
{
  return inp->hlen;
}
int
created2v_cell_body_set_hlen(created2v_cell_body_t *inp, uint16_t val)
{
  inp->hlen = val;
  return 0;
}
size_t
created2v_cell_body_getlen_hdata(const created2v_cell_body_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->hdata);
}

uint8_t
created2v_cell_body_get_hdata(created2v_cell_body_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->hdata, idx);
}

uint8_t
created2v_cell_body_getconst_hdata(const created2v_cell_body_t *inp, size_t idx)
{
  return created2v_cell_body_get_hdata((created2v_cell_body_t*)inp, idx);
}
int
created2v_cell_body_set_hdata(created2v_cell_body_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->hdata, idx, elt);
  return 0;
}
int
created2v_cell_body_add_hdata(created2v_cell_body_t *inp, uint8_t elt)
{
#if SIZE_MAX >= UINT16_MAX
  if (inp->hdata.n_ == UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->hdata, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
created2v_cell_body_getarray_hdata(created2v_cell_body_t *inp)
{
  return inp->hdata.elts_;
}
const uint8_t  *
created2v_cell_body_getconstarray_hdata(const created2v_cell_body_t *inp)
{
  return (const uint8_t  *)created2v_cell_body_getarray_hdata((created2v_cell_body_t*)inp);
}
int
created2v_cell_body_setlen_hdata(created2v_cell_body_t *inp, size_t newlen)
{
  uint8_t *newptr;
#if UINT16_MAX < SIZE_MAX
  if (newlen > UINT16_MAX)
    goto trunnel_alloc_failed;
#endif
  newptr = trunnel_dynarray_setlen(&inp->hdata.allocated_,
                 &inp->hdata.n_, inp->hdata.elts_, newlen,
                 sizeof(inp->hdata.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->hdata.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
size_t
created2v_cell_body_getlen_ignored(const created2v_cell_body_t *inp)
{
  return TRUNNEL_DYNARRAY_LEN(&inp->ignored);
}

uint8_t
created2v_cell_body_get_ignored(created2v_cell_body_t *inp, size_t idx)
{
  return TRUNNEL_DYNARRAY_GET(&inp->ignored, idx);
}

uint8_t
created2v_cell_body_getconst_ignored(const created2v_cell_body_t *inp, size_t idx)
{
  return created2v_cell_body_get_ignored((created2v_cell_body_t*)inp, idx);
}
int
created2v_cell_body_set_ignored(created2v_cell_body_t *inp, size_t idx, uint8_t elt)
{
  TRUNNEL_DYNARRAY_SET(&inp->ignored, idx, elt);
  return 0;
}
int
created2v_cell_body_add_ignored(created2v_cell_body_t *inp, uint8_t elt)
{
  TRUNNEL_DYNARRAY_ADD(uint8_t, &inp->ignored, elt, {});
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}

uint8_t *
created2v_cell_body_getarray_ignored(created2v_cell_body_t *inp)
{
  return inp->ignored.elts_;
}
const uint8_t  *
created2v_cell_body_getconstarray_ignored(const created2v_cell_body_t *inp)
{
  return (const uint8_t  *)created2v_cell_body_getarray_ignored((created2v_cell_body_t*)inp);
}
int
created2v_cell_body_setlen_ignored(created2v_cell_body_t *inp, size_t newlen)
{
  uint8_t *newptr;
  newptr = trunnel_dynarray_setlen(&inp->ignored.allocated_,
                 &inp->ignored.n_, inp->ignored.elts_, newlen,
                 sizeof(inp->ignored.elts_[0]), (trunnel_free_fn_t) NULL,
                 &inp->trunnel_error_code_);
  if (newlen != 0 && newptr == NULL)
    goto trunnel_alloc_failed;
  inp->ignored.elts_ = newptr;
  return 0;
 trunnel_alloc_failed:
  TRUNNEL_SET_ERROR_CODE(inp);
  return -1;
}
const char *
created2v_cell_body_check(const created2v_cell_body_t *obj)
{
  if (obj == NULL)
    return "Object was NULL";
  if (obj->trunnel_error_code_)
    return "A set function failed on this object";
  if (TRUNNEL_DYNARRAY_LEN(&obj->hdata) != obj->hlen)
    return "Length mismatch for hdata";
  return NULL;
}

ssize_t
created2v_cell_body_encoded_len(const created2v_cell_body_t *obj)
{
  ssize_t result = 0;

  if (NULL != created2v_cell_body_check(obj))
     return -1;


  /* Length of u16 hlen */
  result += 2;

  /* Length of u8 hdata[hlen] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->hdata);

  /* Length of u8 ignored[] */
  result += TRUNNEL_DYNARRAY_LEN(&obj->ignored);
  return result;
}
int
created2v_cell_body_clear_errors(created2v_cell_body_t *obj)
{
  int r = obj->trunnel_error_code_;
  obj->trunnel_error_code_ = 0;
  return r;
}
ssize_t
created2v_cell_body_encode(uint8_t *output, const size_t avail, const created2v_cell_body_t *obj)
{
  ssize_t result = 0;
  size_t written = 0;
  uint8_t *ptr = output;
  const char *msg;
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  const ssize_t encoded_len = created2v_cell_body_encoded_len(obj);
#endif

  if (NULL != (msg = created2v_cell_body_check(obj)))
    goto check_failed;

#ifdef TRUNNEL_CHECK_ENCODED_LEN
  trunnel_assert(encoded_len >= 0);
#endif

  /* Encode u16 hlen */
  trunnel_assert(written <= avail);
  if (avail - written < 2)
    goto truncated;
  trunnel_set_uint16(ptr, trunnel_htons(obj->hlen));
  written += 2; ptr += 2;

  /* Encode u8 hdata[hlen] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->hdata);
    trunnel_assert(obj->hlen == elt_len);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->hdata.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }

  /* Encode u8 ignored[] */
  {
    size_t elt_len = TRUNNEL_DYNARRAY_LEN(&obj->ignored);
    trunnel_assert(written <= avail);
    if (avail - written < elt_len)
      goto truncated;
    if (elt_len)
      memcpy(ptr, obj->ignored.elts_, elt_len);
    written += elt_len; ptr += elt_len;
  }


  trunnel_assert(ptr == output + written);
#ifdef TRUNNEL_CHECK_ENCODED_LEN
  {
    trunnel_assert(encoded_len >= 0);
    trunnel_assert((size_t)encoded_len == written);
  }

#endif

  return written;

 truncated:
  result = -2;
  goto fail;
 check_failed:
  (void)msg;
  result = -1;
  goto fail;
 fail:
  trunnel_assert(result < 0);
  return result;
}

/** As created2v_cell_body_parse(), but do not allocate the output
 * object.
 */
static ssize_t
created2v_cell_body_parse_into(created2v_cell_body_t *obj, const uint8_t *input, const size_t len_in)
{
  const uint8_t *ptr = input;
  size_t remaining = len_in;
  ssize_t result = 0;
  (void)result;

  /* Parse u16 hlen */
  CHECK_REMAINING(2, truncated);
  obj->hlen = trunnel_ntohs(trunnel_get_uint16(ptr));
  remaining -= 2; ptr += 2;

  /* Parse u8 hdata[hlen] */
  CHECK_REMAINING(obj->hlen, truncated);
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->hdata, obj->hlen, {});
  obj->hdata.n_ = obj->hlen;
  if (obj->hlen)
    memcpy(obj->hdata.elts_, ptr, obj->hlen);
  ptr += obj->hlen; remaining -= obj->hlen;

  /* Parse u8 ignored[] */
  TRUNNEL_DYNARRAY_EXPAND(uint8_t, &obj->ignored, remaining, {});
  obj->ignored.n_ = remaining;
  if (remaining)
    memcpy(obj->ignored.elts_, ptr, remaining);
  ptr += remaining; remaining -= remaining;
  trunnel_assert(ptr + remaining == input + len_in);
  return len_in - remaining;

 truncated:
  return -2;
 trunnel_alloc_failed:
  return -1;
}

ssize_t
created2v_cell_body_parse(created2v_cell_body_t **output, const uint8_t *input, const size_t len_in)
{
  ssize_t result;
  *output = created2v_cell_body_new();
  if (NULL == *output)
    return -1;
  result = created2v_cell_body_parse_into(*output, input, len_in);
  if (result < 0) {
    created2v_cell_body_free(*output);
    *output = NULL;
  }
  return result;
}
